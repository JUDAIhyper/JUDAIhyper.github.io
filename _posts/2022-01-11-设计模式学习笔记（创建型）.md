---
layout: post
title:  "设计模式学习笔记（一）：创建型"
date:   2022-01-10 15:14:54
categories: 程序设计
tags: design_pattern
excerpt: 设计模式学习笔记，go语言实现
mathjax: true
---

* content
  {:toc}

设计模式是软件设计中常见问题的典型解决方案，可对其进行定制解决代码中的特定设计问题。

根据其复杂程度、细节层级以及应用范围的不同，针对模式的目的特性将其划分为三个不同的组别。

## 创建型模式

创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。

### 工厂模式

工厂模式是一种创建型模式，解决了在不指定具体类的情况下创建产品对象的问题。

工厂方法定义了一个方法，且必须使用该方法代替通过直接调用构造函数来创建对象（`new`操作符）的方式。子类可重写该方法来更改将被创建的对象所属类。

注：Go中缺少类和继承等特性，只能实现简单工厂。

> **为什么要使用工厂模式？**
> 
> 当我们开发一种应用，它需要支持多种类的相同功能，例如联动多款防火墙api，虽然对应的种类不同，但实际是实现同一种功能。

调用工厂方法的代码 （通常被称为*客户端*代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 `调用` 。 客户端知道所有防火墙对象都提供 `增加阻断`方法， 但是并不关心其具体实现方式。

#### 工厂方法模式结构

工厂方法结构分为4种对象：

* **产品** （Product）
  
  * 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。

* **具体产品** （Concrete Products）
  
  * 是产品接口的不同实现。

* **创建者** （Creator）
  
  * 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配
  
  * 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。

* **具体创建者** （Concrete Creators）
  
  * 将会重写基础工厂方法， 使其返回不同类型的产品。
    
    注意， 并不一定每次调用工厂方法都会**创建**新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。

![image](https://judaihyper.github.io/assets/2022-01-11-design/factory/structure.png)

#### 工厂模式适用场景

> <mark>当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。</mark>

工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

> <mark>如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。</mark>

 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？

解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。

> <mark>如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。</mark>

 在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。

让我们思考复用现有对象的方法：

1. 首先， 你需要创建存储空间来存放所有已经创建的对象。
2. 当他人请求一个对象时， 程序将在对象池中搜索可用对象。
3. …然后将其返回给客户端代码。
4. 如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。

可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是**新对象**， 其无法返回现有实例。

因此， 需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。

#### 实现方式

1. 让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。

2. 在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。

3. 在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。
   
   工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 `switch`分支运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。

4. 现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。

5. 如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。
   
   例如， 设想你有以下一些层次结构的类。 基类 `邮件`及其子类 `航空邮件`和 `陆路邮件` ； ​ `运输`及其子类 `飞机`, `卡车`和 `火车` 。 ​ `航空邮件`仅使用 `飞机`对象， 而 `陆路邮件`则会同时使用 `卡车`和 `火车`对象。 你可以编写一个新的子类 （例如 `火车邮件` ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 `陆路邮件`类传递一个参数， 用于控制其希望获得的产品。

6. 如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。

#### 工厂方法模式优缺点

| **优点**                                                                                 | **缺点**                                                                                                             |
| ---------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------- |
| 1. 你可以避免创建者和具体产品之间的紧密耦合。                                            | 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。 |
| <br/>2. 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。 |                                                                                                                      |
| <br/>3. 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。           |                                                                                                                      |

#### 与其它模式的关系

* 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

* <u>抽象工厂模式通常基于一组工厂方法</u>， 但你也可以使用原型模式来生成这些类的方法。

* 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。

* 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。

* 工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。

#### 代码实现

### 抽象工厂

**抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。

#### 适用问题及解决方案

##### 问题

假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：

1. 一系列相关产品， 例如 `椅子`Chair 、 ​ `沙发`Sofa和 `咖啡桌`Coffee­Table 。

2. 系列产品的不同变体。 例如， 你可以使用 `现代`Modern 、 ​ `维多利亚`Victorian 、 ​ `装饰风艺术`Art­Deco等风格生成 `椅子` 、 ​ `沙发`和 `咖啡桌` 。

你需要设法单独生成每件家具对象， 这样才能确保其风格一致。

此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次更新时都去修改核心代码的。

##### 解决方案

首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 `椅子`接口； 所有风格的咖啡桌都实现 `咖啡桌`接口， 以此类推（**同一对象的所有变体都必须放置在同一个类层次结构之中**）。

![image](https://judaihyper.github.io/assets/2022-01-11-design/abfactory/solution1.png)

 接下来， 我们需要声明*抽象工厂*——包含系列中所有产品构造方法的接口。 例如 `create­Chair`创建椅子 、 ​ `create­Sofa`创建沙发和 `create­Coffee­Table`创建咖啡桌 。 这些方法必须返回**抽象**产品类型， 即我们之前抽取的那些接口： ​ `椅子` ， ​ `沙发`和 `咖啡桌`等等。

![image](https://judaihyper.github.io/assets/2022-01-11-design/abfactory/solution2.png)

 那么该如何处理产品变体呢？ 对于系列产品的每个变体， 我们都将基于 `抽象工厂`接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 例如， ​ `现代家具工厂`Modern­Furniture­Factory只能创建 `现代椅子`Modern­Chair 、 ​ `现代沙发`Modern­Sofa和 `现代咖啡桌`Modern­Coffee­Table对象。

客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。

<u>假设客户端想要工厂创建一把椅子。 客户端无需了解工厂类， 也不用管工厂类创建出的椅子类型。 无论是现代风格， 还是维多利亚风格的椅子， 对于客户端来说没有分别， 它只需调用抽象 `椅子`接口就可以了</u>。 这样一来， 客户端只需知道椅子以某种方式实现了 `sit­On`坐下方法就足够了。 此外， 无论工厂返回的是何种椅子变体， 它都会和由同一工厂对象创建的沙发或咖啡桌风格一致。

> 最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。

#### 抽象工厂模式结构

抽象工厂结构分为5大对象：

* **抽象产品** （Abstract Product）
  
  * 为构成系列产品的一组不同但相关的产品声明接口。

* **具体产品** （Concrete Product）
  
  * 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。

* **抽象工厂** （Abstract Factory）
  
  * 接口声明了一组创建各种抽象产品的方法。

* **客户端** （Client）
  
  * 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。

> 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的*抽象*产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。

#### 抽象工厂模式适合应用场景

> **如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。**

 抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。

> **如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。**

 在设计良好的程序中， *每个类仅负责一件事*。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

#### 实现方式

1. 以不同的产品类型与产品变体为维度绘制矩阵。

2. 为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。

3. 声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。

4. 为每种产品变体实现一个具体工厂类。

5. 在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。

6. 找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。

#### 抽象工厂模式优缺点

| **优点**                                                               | **缺点**                                                                |
| ---------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| 你可以确保同一工厂生成的产品相互匹配。                                 | 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。 |
| 你可以避免客户端和具体产品代码的耦合。                                 |                                                                         |
| 单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。 |                                                                         |
| 开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。       |                                                                         |

#### 与其他模式的关系

* 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

* 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。

* 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。

* 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。

* 你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。

* 抽象工厂、 生成器和原型都可以用单例模式来实现。

#### 代码实现

### 生成器模式

**生成器模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。

### 适用问题及解决方案

#### 问题

假设有一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。

我们来思考如何创建一个 `房屋`House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？

最简单的方法是扩展 `房屋`基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。

另一种方法则无需生成子类。 你可以在 `房屋`基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题——拥有大量输入参数的构造函数很多时候并不需要使用全部参数。

#### 解决方案

生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为*生成器*的独立对象中。

![img](https://judaihyper.github.io/assets/2022-01-11-design/builder/solution1.png)

<mark>生成器模式让你能够分步骤创建复杂对象。 生成器不允许其他对象访问正在创建中的产品。</mark>

该模式会将对象构造过程划分为一组步骤， 比如 `build­Walls`创建墙壁和 `build­Door`创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。

当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。

在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。

不同生成器以不同方式执行相同的任务。假设第一个建造者使用木头和玻璃制造房屋， 第二个建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 <u>但是， 只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。</u>

可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的*主管*类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。

严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。

此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。

因此，生成器模式可以让你无需对所有实体对象进行直接的管理，而是通过抽象生成器的方法大大提高开发效率。

### 生成器模式结构

生成器模式包含5大对象：

1. **生成器** （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。
2. **具体生成器** （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。
3. **产品** （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。
4. **主管** （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。
5. **客户端** （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。

`如图是分步骤制造汽车并制作对应型号用户使用手册的示例`

![img](https://judaihyper.github.io/assets/2022-01-11-design/builder/solution2.png)

### 生成器模式适合应用场景

<mark>使用生成器模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。</mark>

> 假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。

如：

```java
class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
```

生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。

<mark>当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。</mark>

> 如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。
> 
> 基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。

<mark>使用生成器构造组合树或其他复杂对象。</mark>

> 生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。
> 
> 生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。

### 实现方法

1. 清晰地定义通用步骤， 确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。

2. 在基本生成器接口中声明这些步骤。

3. 为每个形式的产品创建具体生成器类， 并实现其构造步骤。
   
   不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。

4. 考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式。

5. 客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。

6. 只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。

### 生成器模式优缺点

| 优点                                                            | 缺点                                                        |
| --------------------------------------------------------------- | ----------------------------------------------------------- |
| 你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。           | 由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。 |
| 生成不同形式的产品时， 你可以复用相同的制造代码。               |                                                             |
| 单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。 |                                                             |

## 与其他模式的关系

- 在许多设计工作的初期都会使用**工厂方法**（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用**抽象工厂**、**原型模式**或**生成器模式**（更灵活但更加复杂）。

- **生成器**重点关注如何分步生成复杂对象。 **抽象工厂**专门用于生产一系列相关对象。 **抽象工厂**会马上返回产品， **生成器**则允许你在获取产品前执行一些额外构造步骤。

- 你可以在创建复杂组合模式树时使用生成器， 因为这可使其构造步骤以递归的方式运行。

- 你可以结合使用**生成器**和**桥接模式**： 主管类负责抽象工作， 各种不同的生成器负责实现工作。

- **抽象工厂**、 **生成器**和**原型**都可以用**单例模式**来实现。

### 原型模式
