---
layout: post
title:  "设计模式学习笔记（一）：创建型"
date:   2022-01-10 15:14:54
categories: 程序设计
tags: design_pattern
excerpt: 设计模式学习笔记，go语言实现
mathjax: true
---
# 设计模式（Go语言实现）

- [设计模式（Go语言实现）](#设计模式go语言实现)
  - [创建型模式](#创建型模式)
    - [工厂模式](#工厂模式)
      - [工厂方法模式结构](#工厂方法模式结构)
      - [工厂模式适用场景](#工厂模式适用场景)
      - [实现方式](#实现方式)
      - [工厂方法模式优缺点](#工厂方法模式优缺点)
      - [与其它模式的关系](#与其它模式的关系)
      - [代码实现](#代码实现)
    - [抽象工厂](#抽象工厂)
      - [适用问题及解决方案](#适用问题及解决方案)
        - [问题](#问题)
        - [解决方案](#解决方案)
      - [抽象工厂模式结构](#抽象工厂模式结构)
      - [抽象工厂模式适合应用场景](#抽象工厂模式适合应用场景)
      - [实现方式](#实现方式-1)
      - [抽象工厂模式优缺点](#抽象工厂模式优缺点)
      - [与其他模式的关系](#与其他模式的关系)
      - [代码实现](#代码实现-1)
    - [生成器模式](#生成器模式)
    - [原型模式](#原型模式)

设计模式是软件设计中常见问题的典型解决方案，可对其进行定制解决代码中的特定设计问题。

根据其复杂程度、细节层级以及应用范围的不同，针对模式的目的特性将其划分为三个不同的组别。

## 创建型模式

创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。

### 工厂模式

工厂模式是一种创建型模式，解决了在不指定具体类的情况下创建产品对象的问题。

工厂方法定义了一个方法，且必须使用该方法代替通过直接调用构造函数来创建对象（`new`操作符）的方式。子类可重写该方法来更改将被创建的对象所属类。

注：Go中缺少类和继承等特性，只能实现简单工厂。

> **为什么要使用工厂模式？**
> 
> 当我们开发一种应用，它需要支持多种类的相同功能，例如联动多款防火墙api，虽然对应的种类不同，但实际是实现同一种功能。

调用工厂方法的代码 （通常被称为*客户端*代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 `调用` 。 客户端知道所有防火墙对象都提供 `增加阻断`方法， 但是并不关心其具体实现方式。

#### 工厂方法模式结构

工厂方法结构分为4种对象：

* **产品** （Product）
  
  * 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。

* **具体产品** （Concrete Products）
  
  * 是产品接口的不同实现。

* **创建者** （Creator）
  
  * 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配
  
  * 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。

* **具体创建者** （Concrete Creators）
  
  * 将会重写基础工厂方法， 使其返回不同类型的产品。
    
    注意， 并不一定每次调用工厂方法都会**创建**新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。

![img](https://raw.githubusercontent.com/JUDAIhyper/judaihyper.github.io/master/assets/2022-01-11-设计模式学习笔记（创建型）/工厂方法/structure.png)

#### 工厂模式适用场景

> <mark>当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。</mark>

工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

> <mark>如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。</mark>

 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？

解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。

> <mark>如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。</mark>

 在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。

让我们思考复用现有对象的方法：

1. 首先， 你需要创建存储空间来存放所有已经创建的对象。
2. 当他人请求一个对象时， 程序将在对象池中搜索可用对象。
3. …然后将其返回给客户端代码。
4. 如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。

可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是**新对象**， 其无法返回现有实例。

因此， 需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。

#### 实现方式

1. 让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。

2. 在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。

3. 在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。
   
   工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 `switch`分支运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。

4. 现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。

5. 如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。
   
   例如， 设想你有以下一些层次结构的类。 基类 `邮件`及其子类 `航空邮件`和 `陆路邮件` ； ​ `运输`及其子类 `飞机`, `卡车`和 `火车` 。 ​ `航空邮件`仅使用 `飞机`对象， 而 `陆路邮件`则会同时使用 `卡车`和 `火车`对象。 你可以编写一个新的子类 （例如 `火车邮件` ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 `陆路邮件`类传递一个参数， 用于控制其希望获得的产品。

6. 如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。

#### 工厂方法模式优缺点

| **优点**                                                                                 | **缺点**                                                                                                             |
| ---------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------- |
| 1. 你可以避免创建者和具体产品之间的紧密耦合。                                            | 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。 |
| <br/>2. 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。 |                                                                                                                      |
| <br/>3. 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。           |                                                                                                                      |

#### 与其它模式的关系

* 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

* <u>抽象工厂模式通常基于一组工厂方法</u>， 但你也可以使用原型模式来生成这些类的方法。

* 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。

* 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。

* 工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。

#### 代码实现

### 抽象工厂

**抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。

#### 适用问题及解决方案

##### 问题

假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：

1. 一系列相关产品， 例如 `椅子`Chair 、 ​ `沙发`Sofa和 `咖啡桌`Coffee­Table 。

2. 系列产品的不同变体。 例如， 你可以使用 `现代`Modern 、 ​ `维多利亚`Victorian 、 ​ `装饰风艺术`Art­Deco等风格生成 `椅子` 、 ​ `沙发`和 `咖啡桌` 。

你需要设法单独生成每件家具对象， 这样才能确保其风格一致。

此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次更新时都去修改核心代码的。

##### 解决方案

首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 `椅子`接口； 所有风格的咖啡桌都实现 `咖啡桌`接口， 以此类推（**同一对象的所有变体都必须放置在同一个类层次结构之中**）。

<img src="https://raw.githubusercontent.com/JUDAIhyper/judaihyper.github.io/master/assets/2022-01-11-设计模式学习笔记（创建型）/抽象工厂/solution1.png" title="" alt="avatar" data-align="center">

 接下来， 我们需要声明*抽象工厂*——包含系列中所有产品构造方法的接口。 例如 `create­Chair`创建椅子 、 ​ `create­Sofa`创建沙发和 `create­Coffee­Table`创建咖啡桌 。 这些方法必须返回**抽象**产品类型， 即我们之前抽取的那些接口： ​ `椅子` ， ​ `沙发`和 `咖啡桌`等等。

![img](https://raw.githubusercontent.com/JUDAIhyper/judaihyper.github.io/master/assets/2022-01-11-设计模式学习笔记（创建型）/抽象工厂/solution2.png)

 那么该如何处理产品变体呢？ 对于系列产品的每个变体， 我们都将基于 `抽象工厂`接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 例如， ​ `现代家具工厂`Modern­Furniture­Factory只能创建 `现代椅子`Modern­Chair 、 ​ `现代沙发`Modern­Sofa和 `现代咖啡桌`Modern­Coffee­Table对象。

客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。

<u>假设客户端想要工厂创建一把椅子。 客户端无需了解工厂类， 也不用管工厂类创建出的椅子类型。 无论是现代风格， 还是维多利亚风格的椅子， 对于客户端来说没有分别， 它只需调用抽象 `椅子`接口就可以了</u>。 这样一来， 客户端只需知道椅子以某种方式实现了 `sit­On`坐下方法就足够了。 此外， 无论工厂返回的是何种椅子变体， 它都会和由同一工厂对象创建的沙发或咖啡桌风格一致。

> 最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。

#### 抽象工厂模式结构

抽象工厂结构分为5大对象：

* **抽象产品** （Abstract Product）
  
  * 为构成系列产品的一组不同但相关的产品声明接口。

* **具体产品** （Concrete Product）
  
  * 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。

* **抽象工厂** （Abstract Factory）
  
  * 接口声明了一组创建各种抽象产品的方法。

* **客户端** （Client）
  
  * 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。

> 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的*抽象*产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。

#### 抽象工厂模式适合应用场景

> **如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。**

 抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。

> **如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。**

 在设计良好的程序中， *每个类仅负责一件事*。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

#### 实现方式

1. 以不同的产品类型与产品变体为维度绘制矩阵。

2. 为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。

3. 声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。

4. 为每种产品变体实现一个具体工厂类。

5. 在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。

6. 找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。

#### 抽象工厂模式优缺点

| **优点**                                                               | **缺点**                                                                |
| ---------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| 你可以确保同一工厂生成的产品相互匹配。                                 | 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。 |
| 你可以避免客户端和具体产品代码的耦合。                                 |                                                                         |
| 单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。 |                                                                         |
| 开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。       |                                                                         |

#### 与其他模式的关系

* 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。

* 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。

* 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。

* 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。

* 你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。

* 抽象工厂、 生成器和原型都可以用单例模式来实现。

#### 代码实现

### 生成器模式

### 原型模式

